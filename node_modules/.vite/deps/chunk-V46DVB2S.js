import {
  require_react_dom
} from "./chunk-CIQVVTPY.js";
import {
  require_react
} from "./chunk-ZOIWZPCO.js";
import {
  require_leaflet_src
} from "./chunk-5MKZZDQ7.js";
import {
  __toESM
} from "./chunk-DFKQJ226.js";

// node_modules/@react-leaflet/core/lib/attribution.js
var import_react = __toESM(require_react(), 1);
function useAttribution(map, attribution) {
  const attributionRef = (0, import_react.useRef)(attribution);
  (0, import_react.useEffect)(function updateAttribution() {
    if (attribution !== attributionRef.current && map.attributionControl != null) {
      if (attributionRef.current != null) {
        map.attributionControl.removeAttribution(attributionRef.current);
      }
      if (attribution != null) {
        map.attributionControl.addAttribution(attribution);
      }
    }
    attributionRef.current = attribution;
  }, [
    map,
    attribution
  ]);
}

// node_modules/@react-leaflet/core/lib/circle.js
function updateCircle(layer, props, prevProps) {
  if (props.center !== prevProps.center) {
    layer.setLatLng(props.center);
  }
  if (props.radius != null && props.radius !== prevProps.radius) {
    layer.setRadius(props.radius);
  }
}

// node_modules/@react-leaflet/core/lib/component.js
var import_react3 = __toESM(require_react(), 1);
var import_react_dom = __toESM(require_react_dom(), 1);

// node_modules/@react-leaflet/core/lib/context.js
var import_react2 = __toESM(require_react(), 1);
var CONTEXT_VERSION = 1;
function createLeafletContext(map) {
  return Object.freeze({
    __version: CONTEXT_VERSION,
    map
  });
}
function extendContext(source, extra) {
  return Object.freeze({
    ...source,
    ...extra
  });
}
var LeafletContext = (0, import_react2.createContext)(null);
var LeafletProvider = LeafletContext.Provider;
function useLeafletContext() {
  const context = (0, import_react2.useContext)(LeafletContext);
  if (context == null) {
    throw new Error("No context provided: useLeafletContext() can only be used in a descendant of <MapContainer>");
  }
  return context;
}

// node_modules/@react-leaflet/core/lib/component.js
function createContainerComponent(useElement) {
  function ContainerComponent(props, forwardedRef) {
    const { instance, context } = useElement(props).current;
    (0, import_react3.useImperativeHandle)(forwardedRef, () => instance);
    return props.children == null ? null : import_react3.default.createElement(LeafletProvider, {
      value: context
    }, props.children);
  }
  return (0, import_react3.forwardRef)(ContainerComponent);
}
function createDivOverlayComponent(useElement) {
  function OverlayComponent(props, forwardedRef) {
    const [isOpen, setOpen] = (0, import_react3.useState)(false);
    const { instance } = useElement(props, setOpen).current;
    (0, import_react3.useImperativeHandle)(forwardedRef, () => instance);
    (0, import_react3.useEffect)(function updateOverlay() {
      if (isOpen) {
        instance.update();
      }
    }, [
      instance,
      isOpen,
      props.children
    ]);
    const contentNode = instance._contentNode;
    return contentNode ? (0, import_react_dom.createPortal)(props.children, contentNode) : null;
  }
  return (0, import_react3.forwardRef)(OverlayComponent);
}
function createLeafComponent(useElement) {
  function LeafComponent(props, forwardedRef) {
    const { instance } = useElement(props).current;
    (0, import_react3.useImperativeHandle)(forwardedRef, () => instance);
    return null;
  }
  return (0, import_react3.forwardRef)(LeafComponent);
}

// node_modules/@react-leaflet/core/lib/control.js
var import_react4 = __toESM(require_react(), 1);
function createControlHook(useElement) {
  return function useLeafletControl(props) {
    const context = useLeafletContext();
    const elementRef = useElement(props, context);
    const { instance } = elementRef.current;
    const positionRef = (0, import_react4.useRef)(props.position);
    const { position } = props;
    (0, import_react4.useEffect)(function addControl() {
      instance.addTo(context.map);
      return function removeControl() {
        instance.remove();
      };
    }, [
      context.map,
      instance
    ]);
    (0, import_react4.useEffect)(function updateControl() {
      if (position != null && position !== positionRef.current) {
        instance.setPosition(position);
        positionRef.current = position;
      }
    }, [
      instance,
      position
    ]);
    return elementRef;
  };
}

// node_modules/@react-leaflet/core/lib/events.js
var import_react5 = __toESM(require_react(), 1);
function useEventHandlers(element, eventHandlers) {
  const eventHandlersRef = (0, import_react5.useRef)();
  (0, import_react5.useEffect)(function addEventHandlers() {
    if (eventHandlers != null) {
      element.instance.on(eventHandlers);
    }
    eventHandlersRef.current = eventHandlers;
    return function removeEventHandlers() {
      if (eventHandlersRef.current != null) {
        element.instance.off(eventHandlersRef.current);
      }
      eventHandlersRef.current = null;
    };
  }, [
    element,
    eventHandlers
  ]);
}

// node_modules/@react-leaflet/core/lib/pane.js
function withPane(props, context) {
  const pane = props.pane ?? context.pane;
  return pane ? {
    ...props,
    pane
  } : props;
}

// node_modules/@react-leaflet/core/lib/div-overlay.js
function createDivOverlayHook(useElement, useLifecycle) {
  return function useDivOverlay(props, setOpen) {
    const context = useLeafletContext();
    const elementRef = useElement(withPane(props, context), context);
    useAttribution(context.map, props.attribution);
    useEventHandlers(elementRef.current, props.eventHandlers);
    useLifecycle(elementRef.current, context, props, setOpen);
    return elementRef;
  };
}

// node_modules/@react-leaflet/core/lib/dom.js
var import_leaflet = __toESM(require_leaflet_src(), 1);
function splitClassName(className) {
  return className.split(" ").filter(Boolean);
}
function addClassName(element, className) {
  splitClassName(className).forEach((cls) => {
    import_leaflet.DomUtil.addClass(element, cls);
  });
}

// node_modules/@react-leaflet/core/lib/element.js
var import_react6 = __toESM(require_react(), 1);
function createElementObject(instance, context, container) {
  return Object.freeze({
    instance,
    context,
    container
  });
}
function createElementHook(createElement, updateElement) {
  if (updateElement == null) {
    return function useImmutableLeafletElement(props, context) {
      const elementRef = (0, import_react6.useRef)();
      if (!elementRef.current)
        elementRef.current = createElement(props, context);
      return elementRef;
    };
  }
  return function useMutableLeafletElement(props, context) {
    const elementRef = (0, import_react6.useRef)();
    if (!elementRef.current)
      elementRef.current = createElement(props, context);
    const propsRef = (0, import_react6.useRef)(props);
    const { instance } = elementRef.current;
    (0, import_react6.useEffect)(function updateElementProps() {
      if (propsRef.current !== props) {
        updateElement(instance, props, propsRef.current);
        propsRef.current = props;
      }
    }, [
      instance,
      props,
      context
    ]);
    return elementRef;
  };
}

// node_modules/@react-leaflet/core/lib/layer.js
var import_react7 = __toESM(require_react(), 1);
function useLayerLifecycle(element, context) {
  (0, import_react7.useEffect)(function addLayer() {
    const container = context.layerContainer ?? context.map;
    container.addLayer(element.instance);
    return function removeLayer() {
      var _a;
      (_a = context.layerContainer) == null ? void 0 : _a.removeLayer(element.instance);
      context.map.removeLayer(element.instance);
    };
  }, [
    context,
    element
  ]);
}
function createLayerHook(useElement) {
  return function useLayer(props) {
    const context = useLeafletContext();
    const elementRef = useElement(withPane(props, context), context);
    useAttribution(context.map, props.attribution);
    useEventHandlers(elementRef.current, props.eventHandlers);
    useLayerLifecycle(elementRef.current, context);
    return elementRef;
  };
}

// node_modules/@react-leaflet/core/lib/path.js
var import_react8 = __toESM(require_react(), 1);
function usePathOptions(element, props) {
  const optionsRef = (0, import_react8.useRef)();
  (0, import_react8.useEffect)(function updatePathOptions() {
    if (props.pathOptions !== optionsRef.current) {
      const options = props.pathOptions ?? {};
      element.instance.setStyle(options);
      optionsRef.current = options;
    }
  }, [
    element,
    props
  ]);
}
function createPathHook(useElement) {
  return function usePath(props) {
    const context = useLeafletContext();
    const elementRef = useElement(withPane(props, context), context);
    useEventHandlers(elementRef.current, props.eventHandlers);
    useLayerLifecycle(elementRef.current, context);
    usePathOptions(elementRef.current, props);
    return elementRef;
  };
}

// node_modules/@react-leaflet/core/lib/generic.js
function createControlComponent(createInstance) {
  function createElement(props, context) {
    return createElementObject(createInstance(props), context);
  }
  const useElement = createElementHook(createElement);
  const useControl = createControlHook(useElement);
  return createLeafComponent(useControl);
}
function createLayerComponent(createElement, updateElement) {
  const useElement = createElementHook(createElement, updateElement);
  const useLayer = createLayerHook(useElement);
  return createContainerComponent(useLayer);
}
function createOverlayComponent(createElement, useLifecycle) {
  const useElement = createElementHook(createElement);
  const useOverlay = createDivOverlayHook(useElement, useLifecycle);
  return createDivOverlayComponent(useOverlay);
}
function createPathComponent(createElement, updateElement) {
  const useElement = createElementHook(createElement, updateElement);
  const usePath = createPathHook(useElement);
  return createContainerComponent(usePath);
}
function createTileLayerComponent(createElement, updateElement) {
  const useElement = createElementHook(createElement, updateElement);
  const useLayer = createLayerHook(useElement);
  return createLeafComponent(useLayer);
}

// node_modules/@react-leaflet/core/lib/grid-layer.js
function updateGridLayer(layer, props, prevProps) {
  const { opacity, zIndex } = props;
  if (opacity != null && opacity !== prevProps.opacity) {
    layer.setOpacity(opacity);
  }
  if (zIndex != null && zIndex !== prevProps.zIndex) {
    layer.setZIndex(zIndex);
  }
}

// node_modules/@react-leaflet/core/lib/media-overlay.js
var import_leaflet2 = __toESM(require_leaflet_src(), 1);
function updateMediaOverlay(overlay, props, prevProps) {
  if (props.bounds instanceof import_leaflet2.LatLngBounds && props.bounds !== prevProps.bounds) {
    overlay.setBounds(props.bounds);
  }
  if (props.opacity != null && props.opacity !== prevProps.opacity) {
    overlay.setOpacity(props.opacity);
  }
  if (props.zIndex != null && props.zIndex !== prevProps.zIndex) {
    overlay.setZIndex(props.zIndex);
  }
}

// node_modules/react-leaflet/lib/hooks.js
var import_react9 = __toESM(require_react());
function useMap() {
  return useLeafletContext().map;
}
function useMapEvent(type, handler) {
  const map = useMap();
  (0, import_react9.useEffect)(function addMapEventHandler() {
    map.on(type, handler);
    return function removeMapEventHandler() {
      map.off(type, handler);
    };
  }, [
    map,
    type,
    handler
  ]);
  return map;
}
function useMapEvents(handlers) {
  const map = useMap();
  (0, import_react9.useEffect)(function addMapEventHandlers() {
    map.on(handlers);
    return function removeMapEventHandlers() {
      map.off(handlers);
    };
  }, [
    map,
    handlers
  ]);
  return map;
}

export {
  updateCircle,
  createLeafletContext,
  extendContext,
  LeafletProvider,
  useLeafletContext,
  createContainerComponent,
  createControlHook,
  withPane,
  addClassName,
  createElementObject,
  createElementHook,
  createLayerHook,
  createControlComponent,
  createLayerComponent,
  createOverlayComponent,
  createPathComponent,
  createTileLayerComponent,
  updateGridLayer,
  updateMediaOverlay,
  useMap,
  useMapEvent,
  useMapEvents
};
//# sourceMappingURL=chunk-V46DVB2S.js.map
